Описание проекта.

Pet проект. Сервисы запускаются локально, создавался с целью, на практике
настроить взаимодействие сервисов через брокер сообщений Kafka.

Так же целью было научиться использовать Redis для кеширования ответов из БД 
и равномерной обработки запросов от разных пользователей к БД

Используется:
* Kafka для взаимодействия между модулями
* Redis для распределения запросов от пользователей к БД и кеширования ответов
* Postgress для БД
* Spring Data JPA для представления сущностей БД java объектами
* Spring Boot Starter Web для рест контроллеров
* GitHub для хранения версий
* Docker для контейнеров Kafka, Redis, Postgres
  (bitnami/kafka:1.1.1-r267, bitnami/zookeeper:3.5.5-r43, redis:5.0.14, postgres:14.5) 
  (в БД должна быть создана таблица )

-- Кейс 1 (restModule, dataModule):
Задача: Организовать передачу сообщений через топик Kafka.

- restModule: Обращение на ендпоинт :8087/send-messages?count=*&userId=*
генерирует count сообщений с определенным userId и рандомным текстом, отправляет все сообщения 
в топик "user-requests" с единственной партицией, возвращает пользователю ответ с количеством 
отправленных сообщений. 
- dataModule: Слушает топик "user-requests" записывает все сообщения по очереди в БД


-- Кейс 2 (restModule, dataModuleLimited):
Задача: Представим, что БД имеет лимит = 1запись/секунду. Если в очереди перед сообщением от
user_id=3 уже есть по сто сообщений от user_id=2 и user_id=1 он будет вынужден ждать 200 сек
пока его сообщение будет обработано. Необходимо обрабатывать сообщения поочередно для каждого
пользователя, чтобы сообщение от user_id=3 было обработано на 3 секунде.

- restModule: Обращения на ендпоинты :8087/send-messages?count=*&userId=*
генерируют count сообщений с определенным userId и рандомным текстом, отправляет все сообщения 
в топик "user-requests" с единственной партицией, возвращает пользователю ответ с количеством 
отправленных сообщений.

- dataModuleLimited: Записывает сообщния в списки Redis, сгруппированные по userId, сохраняя 
порядок их поступления. Каждую секунду в БД записывается сообщение из следующего списка по принципу
"первый пришел - первый ушел". Так реализуется равномерная обработка сообщений всех пользователей. 
Преимущество такой реализации на redis в том, что он реплицируемый и при перезапуске приложения или
отказе одного из серверов редиса, сообщения не будут потеряны.


-- Кейс 3 (restModule, dataModuleMultiPart):
Задача: Разбить топик на партиции и обработать их паралельно.

- restModule: Обращения на ендпоинты :****/send-messages-multi?count=*&userId=*
генерируеют count сообщений с определенным userId и рандомным текстом, отправляет все сообщения 
в топик "user-requests" с шестью партициями, возвращает пользователю ответ с количеством 
отправленных сообщений

- dataModuleMultiPart: запускается в шести экземплярах на шести разных портах (необходимо создать
шесть конфигураций запуска данного модуля и запустить каждую). Каждый экземпляр сервиса обрабатывает
свою партицию паралельно с другими экземплярами.


-- Кейс 4 (dataModuleCached):
Задача: Организовать кеш ответов для популярных запросов к БД.

- dataModuleCached: Обращение на ендпоинт :8086/getDb?messageId=* вернет сообщение с id=* из БД 
и запишет его в Redis с временем жизни в кеше = 30 сек. 
Обращение на ендпоинт :8086//getCached?messageId=* вернет сообщение с id=* из Redis и обновит 
его время жизни
*На локальном компьютере запрос к БД отрабатывает меньше чем за 1ms а к Redis
примерно за 5ms ))
